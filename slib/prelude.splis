(do
  ;; TODO: (println ...)

  ;; `fun` provides a macro to streamline function definition.
  ;; Instead of defining the not-function the conventional way
  ;;
  ;; ```(def! not (fn* [x] (if x false true)))```
  ;;
  ;; one can leverage `fun` to achief a mor concise definition:
  ;;
  ;; ```(fun not [x] (if x false true))```
  ;;
  ;; @sym   name  The name of the function.
  ;; @(sym) args  The list of arument symbols.
  ;; @(any) body  The body of the function.
  (defmacro! fun
    (fn* [name args body]
      `(def! ~name (fn* ~args ~body)) ))

  ;; `use` reads, parses and evaluates a splis source file.
  ;;
  ;; @str path  The path to a splis source file.
  (fun use [path]
    (eval (parse (read-file path))))

  ;; `not` returns `false` if `x` is truthy; `true` otherwise.
  ;;
  ;; @any x  The value.
  ;; @return [bool] `false` if `x` is truthy; `true` otherwise.
  (fun not [x] (if x false true))

  ;; `inc` increments the number `n` by one.
  ;;
  ;; @num n  A number.
  (fun inc [n] (+ n 1))

  ;; `dec` decrements the number `n` by one.
  ;;
  ;; @num n  A number.
  (fun dec [n] (- n 1))

  ;; `map` applies a function of one argument to each element of a list and
  ;; returns a list of the application results in the same order as the
  ;; elements.
  ;;
  ;; @fun(T)any f   A unary function.
  ;; @(T)       xs  A list of elements.
  ;; @return  The list of elements applied to the unary function individually.
  (fun map [f xs]
    (if (empty? xs)
      xs ; Will preserve the type of the sequence.
      (:: (f (head xs)) (map f (tail xs)))))

  ;; Left-reduce a list.
  ; (fun reduce [f b xs]
  ;   (if (empty? xs)
  ;     b
  ;     (reduce f (f b head(xs)) tail(xs))))
)
