(do
  (println "Chapter 1")
  (println "=========")

  (println)
  (println "Exercise 1.1")
  (println "------------")
  (println 10)
  (println (+ 5 3 4))
  (println (- 9 1))
  (println (/ 6 2))
  (println (+ (* 2 4) (- 4 6)))
  (def a 3)
  (def b (+ a 1))
  (println (+ a b (* a b)))
  (println (= a b))
  (println
    (if (and (> b a) (< b (* a b)))
      b
      a))
  (println
    (cond (= a 4) 6
          (= b 4) (+ 6 7 a)
          else 25))
  (println (+ 2 (if (> b a) b a)))
  (println
    (* (cond (> a b) a
             (< a b) b
             else (- 1))
       (+ a 1)))

  (println)
  (println "Exercise 1.2")
  (println "------------")
  (println
    (/ (+ 5
          4
          (- 2 (- 3 (+ 6 (/ 4 5)))))
       (* 3
          (- 6 2)
          (- 2 7))))

  (println)
  (println "Exercise 1.3")
  (println "------------")
  (defn square [x] (* x x))
  (defn sum-of-squares [xs] (sum (map square xs)))

  (defn max-2 [a b c]
    (let (lst [a b c]
          min (minimum lst))
      (remove (fn [x] (= x min)) lst)))

  (println (max-2 1 2 3) " should be [2 3].")
  (println (max-2 4 3 7) " should be [4 7].")

  (defn sum-of-squares-of-max-2 [a b c]
    (sum-of-squares (max-2 a b c)))

  (println (sum-of-squares-of-max-2 1 2 3) " should be 13.")
  (println (sum-of-squares-of-max-2 4 3 7) " should be 65.")

  (println)
  (println "Exercise 1.4")
  (println "------------")
  ; Depending on the value of b we will either add or subtract it from a.
  ; If b < 0 we subtract a negative number yielding the absolute value of b.
  (defn a-plus-abs-b [a b] ((if (> b 0) + -) a b))

  (println (a-plus-abs-b 1 2) " should be 3.")
  (println (a-plus-abs-b 1 (- 2)) " should be 3.")

  (println)
  (println "Exercise 1.5")
  (println "------------")
  (defn p [] (p))
  (defn test [x y] (if (= x 0) 0 y))
  ; Splis uses applicative-order evaluation.
  ; The call (test 0 p) will loop forever...
  (println (test 0 p))
  ; ...well, or not.
  ; Why is it printing the 0 and stopping?

  (println)
  (println "1.1.7 Example: Square Roots by Newton's Method")
  (println "----------------------------------------------")
  (defn sqrt-good-enough? [guess x]
    (< (abs (- (square guess) x)) 0.001))
  (defn sqrt-improve [guess x]
    (averagev guess (/ x guess)))
  (defn sqrt-iter [guess x]
    (if (sqrt-good-enough? guess x)
      guess
      (sqrt-iter (sqrt-improve guess x) x) ))
  (defn sqrt [x] (sqrt-iter 1.0 x))

  (println "(sqrt 9) = " (sqrt 9))
  (println "(sqrt (+ 100 37)) = " (sqrt (+ 100 37)))
  (println "(sqrt (+ (sqrt 2) (sqrt 3))) = " (sqrt (+ (sqrt 2) (sqrt 3))))
  (println "(square (sqrt 1000)) = " (square (sqrt 1000)))

  (println)
  (println "Exercise 1.6")
  (println "------------")
  (println "sqrt-iter will recurse infinitely because all arguments to new-if")
  (println "will be evaluated before the invocation of new-if. This includes")
  (println "the else-clause which is a recursive call to sqrt-iter.")

  (println)
  (println "Chapter 1 completed.")
)
