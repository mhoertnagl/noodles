(do
  (use "core/prelude")

  (println "Chapter 1")
  (println "=========")

  (println)
  (println "Exercise 1.1")
  (println "------------")
  (println 10)
  (println (+ 5 3 4))
  (println (- 9 1))
  (println (/ 6 2))
  (println (+ (* 2 4) (- 4 6)))
  (def a 3)
  (def b (+ a 1))
  (println (+ a b (* a b)))
  (println (= a b))
  (println
    (if (and (> b a) (< b (* a b)))
      b
      a))
  (println
    (cond (= a 4) 6
          (= b 4) (+ 6 7 a)
          else 25))
  (println (+ 2 (if (> b a) b a)))
  (println
    (* (cond (> a b) a
             (< a b) b
             else (- 1))
       (+ a 1)))

  (println)
  (println "Exercise 1.2")
  (println "------------")
  (println
    (/ (+ 5
          4
          (- 2 (- 3 (+ 6 (/ 4 5)))))
       (* 3
          (- 6 2)
          (- 2 7))))

  (println)
  (println "Exercise 1.3")
  (println "------------")
  (defn square [x] (* x x))
  (defn sum-of-squares [xs] (sum (map square xs)))

  (defn max-2 [a b c]
    (remove (fn [x] (= x (minimum a b c))) [a b c]))
  ; (defn max-2 [& args]
  ;   (set min (minimumv args))
  ;   (set f (fn [x] (= x min)))
  ;   (remove f args))
  ;; TODO: min is not available in closure - why?
  ; (defn max-2 [a b c]
  ;   (let (min (minimum a b c))
  ;     (remove (fn [x] (= x min)) [a b c]) ))

  (println (max-2 1 2 3) " should be [2 3].")
  (println (max-2 4 3 7) " should be [4 7].")

  (defn sum-of-squares-of-max-2 [a b c]
    (sum-of-squares (max-2 a b c)))

  (println (sum-of-squares-of-max-2 1 2 3) " should be 13.")
  (println (sum-of-squares-of-max-2 4 3 7) " should be 65.")

  (println)
  (println "Exercise 1.4")
  (println "------------")
  ; Depending on the value of b we will either add or subtract it from a.
  ; If b < 0 we subtract a negative number yielding the absolute value of b.
  (defn a-plus-abs-b [a b] ((if (> b 0) .+ .-) a b))

  (println (a-plus-abs-b 1 2) " should be 3.")
  (println (a-plus-abs-b 1 (- 2)) " should be 3.")

  (println)
  (println "Exercise 1.5")
  (println "------------")
  (defn p [] (rec (p)))
  (defn test2 [x y] (if (= x 0) 0 y))
  ; Splis uses applicative-order evaluation.
  ; The call (test2 0 (p)) will loop forever...
  ; (println (test2 0 (p)))

  (println)
  (println "1.1.7 Example: Square Roots by Newton's Method")
  (println "----------------------------------------------")
  (defn sqrt-good-enough? [guess x]
    (< (abs (- (square guess) x)) 0.001))
  (defn sqrt-improve [guess x]
    (average guess (/ x guess)))
  (defn sqrt-iter [guess x]
    (if (sqrt-good-enough? guess x)
      guess
      (rec (sqrt-iter (sqrt-improve guess x) x) )))
  (defn sqrt [x] (sqrt-iter 1.0 x))

  (println "(sqrt 9) = " (sqrt 9))
  (println "(sqrt (+ 100 37)) = " (sqrt (+ 100 37)))
  (println "(sqrt (+ (sqrt 2) (sqrt 3))) = " (sqrt (+ (sqrt 2) (sqrt 3))))
  (println "(square (sqrt 1000)) = " (square (sqrt 1000)))

  (println)
  (println "Exercise 1.6")
  (println "------------")
  (println "sqrt-iter will recurse infinitely because all arguments to new-if\n"
           "will be evaluated before the invocation of new-if. This includes\n"
           "the else-clause which is a recursive call to sqrt-iter.")

  (println)
  (println "Exercise 1.7")
  (println "------------")
  (println "(sqrt (/ 1000)) = " (sqrt (/ 1000)))
  (println "The correct value would be 0.031622777 but\n"
           "(- (square (sqrt (/ 1000))) (/ 1000)) = "
           (- (square (sqrt (/ 1000))) (/ 1000))
           " < 0.001 \nwhich is already 'good enough'.")
  ; TODO: The following loops forever.
  ; (println "(sqrt 99999999999999999999999) = " (sqrt 99999999999999999999999))

  (defn sqrt2-good-enough? [g2 g1]
    (< (abs (- g2 g1)) (/ g1 1000)))
  (defn sqrt2-iter [g2 g1 x]
    (if (sqrt2-good-enough? g2 g1)
      g2
      (rec (sqrt2-iter (sqrt-improve g2 x) g2 x)) ))
  (defn sqrt2 [x] (sqrt2-iter (sqrt-improve 1.0 x) 1.0 x))

  (println "(sqrt2 9) = " (sqrt2 9))
  (println "(sqrt2 (+ 100 37)) = " (sqrt2 (+ 100 37)))
  (println "(sqrt2 (+ (sqrt2 2) (sqrt2 3))) = " (sqrt2 (+ (sqrt2 2) (sqrt2 3))))
  (println "(square (sqrt2 1000)) = " (square (sqrt2 1000)))
  (println "(sqrt2 (/ 1000)) = " (sqrt2 (/ 1000)))
  (println "sqrt2 performs better on small numbers.")

  (println)
  (println "Exercise 1.8")
  (println "------------")
  ;; TODO: Loops forever.
  (defn good-enough? [g2 g1]
    (< (abs (- g2 g1)) (/ g1 1000)))
  (defn improve [guess x]
    (average guess guess (/ x (square guess))))
  (defn iter [g2 g1 x]
    (if (good-enough? g2 g1)
      g2
      (rec (iter (improve g2 x) g2 x))))
  (defn curt [x] (iter (improve 1.0 x) 1.0 x))

  (println "(curt 27) = " (curt 27))
  (println "(curt (/ 1000)) = " (curt (/ 1000)))

  ;; Exercise 1.9
  ;; ------------
  ;;
  ;; (+ 4 5)
  ;; (inc (+ 3 5))
  ;; (inc (inc (+ 2 5)))
  ;; (inc (inc (inc (+ 1 5))))
  ;; (inc (inc (inc (inc (+ 0 5)))))
  ;; (inc (inc (inc (inc 5))))
  ;; (inc (inc (inc 6)))
  ;; (inc (inc 7))
  ;; (inc 8)
  ;; 9
  ;;
  ;; (+ 4 5)
  ;; (+ 3 6)
  ;; (+ 2 7)
  ;; (+ 1 8)
  ;; (+ 0 9)
  ;; 9
  ;;
  ;; First one is recursive, second one is iterative.

  (println)
  (println "Exercise 1.10")
  (println "-------------")
  (defn ackermann [x y]
    (cond (= y 0) 0
          (= x 0) (* 2 y)
          (= y 1) 2
          else (ackermann (dec x)
                          (ackermann x (dec y))) ))

  (println "(ackermann 1 10) = " (ackermann 1 10))
  (println "(ackermann 2 4) = " (ackermann 2 4))
  (println "(ackermann 3 3) = " (ackermann 3 3))

  ;; (f n) = (A 0 n) = 2*n
  ;; (g n) = (A 1 n) = 2^n
  ;; (h n) = (A 2 n) = 2^(2^n)

  (println)
  (println "Exercise 1.11")
  (println "-------------")
  (defn tib-rec [n]
    (if (< n 3)
      n
      (+ (tib-rec (- n 1))
         (tib-rec (- n 2))
         (tib-rec (- n 3))) ))

  (println "(tib-rec 1) = " (tib-rec 1))
  (println "(tib-rec 2) = " (tib-rec 2))
  (println "(tib-rec 3) = " (tib-rec 3))
  (println "(tib-rec 4) = " (tib-rec 4))
  (println "(tib-rec 5) = " (tib-rec 5))
  (println "(tib-rec 6) = " (tib-rec 6))

  (defn tib-iter [a b c n]
    (if (= n 0)
      c
      (rec (tib-iter (+ a b c) a b (- n 1))) ))

  (defn tib [n] (tib-iter 2 1 0 n))

  (println "(tib 1) = " (tib 1))
  (println "(tib 2) = " (tib 2))
  (println "(tib 3) = " (tib 3))
  (println "(tib 4) = " (tib 4))
  (println "(tib 5) = " (tib 5))
  (println "(tib 6) = " (tib 6))

  ; (println)
  ; (println "Exercise 1.12")
  ; (println "-------------")

  ; ;; Exercise 1.13
  ; ;; -------------
  ; ;;
  ; ;;

  (println)
  (println "Chapter 1 completed.")
)
