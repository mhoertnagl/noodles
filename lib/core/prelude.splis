(do
  ;; `fun` provides a macro to streamline function definition.
  ;; Instead of defining the not-function the conventional way
  ;;
  ;; ```(def not (fn [x] (if x false true)))```
  ;;
  ;; one can leverage `defn` to achief a more concise definition:
  ;;
  ;; ```(defn not [x] (if x false true))```
  ;;
  ;; @param sym   name  The name of the function.
  ;; @param (sym) args  The list of arument symbols.
  ;; @param (any) body  The body of the function.
  (defmacro defn [name args & body] (def name (fn args (do @body))))

  (defmacro print [& args] (write *STD-OUT* @args))

  (defmacro println [& args] (print @args "\n"))

  (defmacro error [& args] (do (write *STD-ERR* "ERROR:" @args "\n")
                               (halt)))

  ;; `nil?` returns true if and only if `x` is `nil`.
  ;;
  ;; @param  any x  A value.
  ;; @return bool   `true` iff `x` is `nil`.
  ; (defn nil? [x] (= x nil))

  ;; (bool? )
  ;; (int? )
  ;; (float? )
  ;; (str? )
  ;; (vec? )

  ;; `true?` returns true if and only if `x` is the boolean `true`.
  ;;
  ;; @param  any x  A value.
  ;; @return bool  `true` iff `x` is the boolean `true`.
  ; (defn true? [x] (= x true))

  ;; `false?` returns true if and only if `x` is the boolean `false`.
  ;;
  ;; @param  any x  A value.
  ;; @return bool  `true` iff `x` is the boolean `false`.
  ; (defn false? [x] (= x false))

  ;; `else` is an alias for the boolean atom `true`. Used in `cond` expressions
  ;; to denote the default branch.
  (defmacro else [] true)

  ;; `identity` returns the argument itself.
  ;;
  ;; @param  any x  Any argument.
  ;; @return any    `x` itself.
  (defn identity [x] x)
  ; (defmacro identity [x] x)

  ;; `inc` increments the number `n` by one.
  ;;
  ;; @param  num n  A number.
  ;; @return num    `n + 1`.
  (defn inc [n] (+ n 1))

  ;; `dec` decrements the number `n` by one.
  ;;
  ;; @param  num n  A number.
  ;; @return num    `n - 1`.
  (defn dec [n] (- n 1))

  ;; `pos?` returns `true` if the value `n` is greater than `0`; `false`
  ;; otherwise.
  ;;
  ;; @param  num  n  A number.
  ;; @return bool    `true` if `n` is positive; `false` otherwise.
  (defn pos? [n] (> n 0))

  ;; `non-neg?` returns `true` if the value `n` is greater than or equal `0`; `
  ;; false` otherwise.
  ;;
  ;; @param  num  n  A number.
  ;; @return bool    `true` if `n` is non-negative; `false` otherwise.
  (defn non-neg? [n] (>= n 0))

  ;; `neg?` returns `true` if the value `n` is less than `0`; `false`
  ;; otherwise.
  ;;
  ;; @param  num  n  A number.
  ;; @return bool    `true` if `n` is negative; `false` otherwise.
  (defn neg? [n] (< n 0))

  ;; `abs` computes the absolute value of `n`.
  ;;
  ;; @param  num n  A number.
  ;; @return num    The absolute value `|n|`.
  (defn abs [n] (if (pos? n) n (- n)))

  ;; `empty?` returns the number of elements in the vector `xs`.
  ;;
  ;; @param  (any) xs  A vector of elements.
  (defmacro empty? [xs] (= (len xs) 0))

  (defn vec [& args] args)

  (defmacro fst [xs] (nth 0 xs))
  (defmacro snd [xs] (nth 1 xs))
  (defmacro trd [xs] (nth 2 xs))
  (defmacro rst [xs] (drop 1 xs))

  ;; `range` returns the list of numbers from `start` (inclusive) to `end`
  ;; (exclusive). If `start >= end` it will return the empty list.
  ;; `step` denotes the increment added to `start` until it is greater or equal
  ;; to `end`.
  ;;
  ;; @param  num start  The start number (included).
  ;; @param  num end    The end number (excluded).
  ;; @param  num step   The increment step size.
  ;; @return (num)      The sequence of numbers from `a` up to `b`.
  (defn range [start end step] (_range start end step []))

    (defn _range [start end step acc]
      (if (>= start end)
        acc
        (rec (_range start (- end step) step (:: end acc))) ))

  ;; `irange` returns the list of integers from `start` (inclusive) to `end`
  ;; (exclusive). If `start >= end` it will return the empty list.
  ;; This is the same as `(range start end 1)`.
  ;;
  ;; @param  num start  The start number (included).
  ;; @param  num end    The end number (excluded).
  ;; @return (num)      The sequence of integers from `a` up to `b`.
  (defn irange [start end] (range start end 1))

  ;; `reduce` reduces a sequence of elements into a single element by successive
  ;; application of the binary function `f` in a left-associative fashion where
  ;; `b` is the initial value.
  ;; If the list is empty, `reduce` will return `b`.
  ;;
  ;; @param  fun(S T)T f   A binary function.
  ;; @param  T         b   The initial value.
  ;; @param  (S)       xs  A list of elements.
  ;; @return T             The left-associative reduction of `xs` into a single
  ;;                       element.
  (defn reduce [f b xs]
    (if (empty? xs)
      b
      (rec (reduce f (f (fst xs) b) (rst xs))) ))

  (defn fold [f xs]
    (if (empty? xs)
      (error "[fold] list is empty")
      (reduce f (fst xs) (rst xs)) ))

  ;; `map` applies a function of one argument to each element of a list and
  ;; returns a list of the application results in the same order as the
  ;; elements.
  ;;
  ;; @param  fun(T)S f   A unary function.
  ;; @param  (T)     xs  A list of elements.
  ;; @return (S)         The list of elements applied to the unary function
  ;;                     individually.
  (defn map [f xs] (_map f xs []))

    (defn _map [f xs acc]
      (if (empty? xs)
        acc
        (rec (_map f (rst xs) (:: (f (fst xs)) acc))) ))

  ; (defn flat-map [p xs]
  ;   (if (empty? xs)
  ;     ()
  ;     (::: (f (head xs)) (map f (tail xs)))))

  (defn filter [p xs] (_filter p xs []))

    (defn _filter [p xs acc]
      (cond (empty? xs)  acc
            (p (fst xs)) (rec (_filter p (rst xs) (:: (fst xs) acc)))
            else         (rec (_filter p (rst xs) acc)) ))

  ; TODO: Won't work...
  ;       needs calling of arguments outside of the current function context.
  ; (defn remove [p xs] (filter '(not (p ~x)) xs))
  ; (defn remove [p xs] (filter (fn [x] (not (p x))) xs))

  (defn all [p xs]
    (cond (empty? xs)        true
          (not (p (fst xs))) false
          else               (rec (all p (rst xs))) ))

  (defn any [p xs]
    (cond (empty? xs)  false
          (p (fst xs)) true
          else         (rec (any p (rst xs))) ))

  ;; (defn reverse [xs])

  (defn take [n xs] (_take n xs []))

    (defn _take [n xs acc]
      (cond (empty? xs) acc
            (<= n 0)    acc
            else        (rec (_take (- n 1) (rst xs) (:: (fst xs) acc))) ))

  (defn drop-while [p xs]
    (cond (empty? xs)  xs
          (p (fst xs)) (rec (drop-while p (rst xs)))
          else         xs ))

  ; (defn take-while [p xs]
  ;   (cond
  ;     (empty? xs) xs
  ;     (p (head xs)) (:: (head xs) (take-while p (tail xs)))
  ;     else () ))

  (defn zip-with [f xs ys] (_zip-with f xs ys []))

    (defn _zip-with [f xs ys acc]
      (cond (empty? xs) acc
            (empty? ys) acc
            (rec (_zip-with f
                            (rst xs)
                            (rst ys)
                            (:: (f (fst xs) (fst ys)) acc))) ))

  (defn zip [xs ys] (zip-with vec xs ys))

  (defn repeat [n v] (_repeat n v []) )

    (defn _repeat [n v acc]
      (if (<= n 0)
        []
        (rec (_repeat (- n 1) v (:: v acc))) ))

  ;; (defn flatten [xs])
  ; (use "core/math")
  ; (use "core/io")
)
